this.BX=this.BX||{};this.BX.Tasks=this.BX.Tasks||{};this.BX.Tasks.V2=this.BX.Tasks.V2||{};this.BX.Tasks.V2.Provider=this.BX.Tasks.V2.Provider||{};(function(s,e,t,r){"use strict";function i(s){var e;return{id:s.id,name:s.name,image:(e=s.image)==null?void 0:e.src,type:s.type}}var a=babelHelpers.classPrivateFieldLooseKey("getUnloadedIds");class o{constructor(){Object.defineProperty(this,a,{value:n})}getUrl(s){return`/company/personal/user/${s}/`}async list(s){const t=babelHelpers.classPrivateFieldLooseBase(this,a)[a](s);if(t.length===0){return}try{const s=await r.apiClient.post("User.list",{ids:t});const a=s.map((s=>i(s)));await this.$store.dispatch(`${e.Model.Users}/upsertMany`,a)}catch(s){console.error("UserService: list error",s)}}hasUsers(s){return babelHelpers.classPrivateFieldLooseBase(this,a)[a](s).length===0}get $store(){return t.Core.getStore()}}function n(s){const t=this.$store.getters[`${e.Model.Users}/getByIds`](s);const r=new Set(t.map((({id:s})=>s)));return s.filter((s=>!r.has(s)))}const l=new o;const c={mapDtoToModel:i};s.UserMappers=c;s.userService=l})(this.BX.Tasks.V2.Provider.Service=this.BX.Tasks.V2.Provider.Service||{},BX.Tasks.V2.Const,BX.Tasks.V2,BX.Tasks.V2.Lib);
//# sourceMappingURL=user-service.bundle.map.js