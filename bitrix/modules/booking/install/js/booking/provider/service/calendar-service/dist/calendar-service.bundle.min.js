this.BX=this.BX||{};this.BX.Booking=this.BX.Booking||{};this.BX.Booking.Provider=this.BX.Booking.Provider||{};(function(e,t,s,a,r,o){"use strict";async function*i(e,t,s,a){const r=e<t?1:-1;const o=l(3,r,t);let{fromDate:i,toDate:n}=o(new Date(e));const c=e=>r===1?e>t:e<t;while(!c(i.getTime())){const e=await a({...s,WITHIN:{DATE_FROM:i.getTime()/1e3,DATE_TO:n.getTime()/1e3}});const t=o(r===1?n:i);i=t.fromDate;n=t.toDate;if(e.foundDates.length>0){yield e}}}function l(e,t,s){let a=e;return function(e){a++;const r=new Date(e);r.setMonth(r.getMonth()+(a+1)*t);r.setDate(0);if(t===1){return{fromDate:e,toDate:r.getDate()>s?new Date(s):r}}const o=r.getTime()<s?new Date(s):r;const i=e;if(i.getTime()===o.getTime()){i.setDate(i.getDate()+1)}return{fromDate:o,toDate:i}}}var n=babelHelpers.classPrivateFieldLooseKey("filterMarksRequests");var c=babelHelpers.classPrivateFieldLooseKey("filterBookingDatesCountRequests");var d=babelHelpers.classPrivateFieldLooseKey("lastFilterMarksRequest");var b=babelHelpers.classPrivateFieldLooseKey("freeMarksRequests");var u=babelHelpers.classPrivateFieldLooseKey("lastFreeMarksRequest");var h=babelHelpers.classPrivateFieldLooseKey("counterMarksRequests");var p=babelHelpers.classPrivateFieldLooseKey("requestLoadMarks");var v=babelHelpers.classPrivateFieldLooseKey("requestFilterMarks");var F=babelHelpers.classPrivateFieldLooseKey("requestNextBookingDates");var f=babelHelpers.classPrivateFieldLooseKey("requestCounterMarks");var g=babelHelpers.classPrivateFieldLooseKey("requestBookingsDateCount");var B=babelHelpers.classPrivateFieldLooseKey("offset");var P=babelHelpers.classPrivateFieldLooseKey("timezone");class D{constructor(){Object.defineProperty(this,P,{get:w,set:void 0});Object.defineProperty(this,B,{get:M,set:void 0});Object.defineProperty(this,g,{value:C});Object.defineProperty(this,f,{value:y});Object.defineProperty(this,F,{value:L});Object.defineProperty(this,v,{value:k});Object.defineProperty(this,p,{value:H});Object.defineProperty(this,n,{writable:true,value:{}});Object.defineProperty(this,c,{writable:true,value:{}});Object.defineProperty(this,d,{writable:true,value:void 0});Object.defineProperty(this,b,{writable:true,value:{}});Object.defineProperty(this,u,{writable:true,value:void 0});Object.defineProperty(this,h,{writable:true,value:{}})}clearCache(e,t){Object.keys(babelHelpers.classPrivateFieldLooseBase(this,n)[n]).forEach((s=>{const{dateTs:a,sortedResources:r}=JSON.parse(s);if(e===a){delete babelHelpers.classPrivateFieldLooseBase(this,n)[n][s]}for(const e of r){if(e.includes(t)){delete babelHelpers.classPrivateFieldLooseBase(this,n)[n][s];break}}}))}clearFilterCache(){babelHelpers.classPrivateFieldLooseBase(this,n)[n]={};this.clearDataCountCache()}clearDataCountCache(){babelHelpers.classPrivateFieldLooseBase(this,c)[c]={}}async loadMarks(e,r){try{var o,i;if(!t.Type.isArrayFilled(r)){return}const l=r.map((e=>e.sort(((e,t)=>e-t)))).sort(((e,t)=>e[0]-t[0]));const n=JSON.stringify({dateTs:e,sortedResources:l});(i=(o=babelHelpers.classPrivateFieldLooseBase(this,b)[b])[n])!=null?i:o[n]=babelHelpers.classPrivateFieldLooseBase(this,p)[p](e,r);babelHelpers.classPrivateFieldLooseBase(this,u)[u]=babelHelpers.classPrivateFieldLooseBase(this,b)[b][n];const c=await babelHelpers.classPrivateFieldLooseBase(this,b)[b][n];if(babelHelpers.classPrivateFieldLooseBase(this,b)[b][n]!==babelHelpers.classPrivateFieldLooseBase(this,u)[u]){return}await s.Core.getStore().dispatch(`${a.Model.Interface}/setFreeMarks`,c)}catch(e){console.error("BookingService: loadMarks error",e)}}async loadFilterMarks(e,t=false){try{var r,i;const l=t?o.bookingDateCountFilter.prepareFutureFilter(e,true):o.bookingFilter.prepareFilter(e,true);const c=JSON.stringify(l);(i=(r=babelHelpers.classPrivateFieldLooseBase(this,n)[n])[c])!=null?i:r[c]=babelHelpers.classPrivateFieldLooseBase(this,v)[v](l);babelHelpers.classPrivateFieldLooseBase(this,d)[d]=babelHelpers.classPrivateFieldLooseBase(this,n)[n][c];const{foundDates:b,foundDatesWithCounters:u}=await babelHelpers.classPrivateFieldLooseBase(this,n)[n][c];if(babelHelpers.classPrivateFieldLooseBase(this,n)[n][c]!==babelHelpers.classPrivateFieldLooseBase(this,d)[d]){return}await Promise.all([s.Core.getStore().dispatch(`${a.Model.Filter}/addFilterDates`,b),s.Core.getStore().dispatch(`${a.Model.Filter}/setFilteredMarks`,b),s.Core.getStore().dispatch(`${a.Model.Interface}/setCounterMarks`,u)])}catch(e){console.error("BookingService: loadFilterMarks error",e)}}async loadCounterMarks(e,t=false){try{const i=e.toString();if(t){babelHelpers.classPrivateFieldLooseBase(this,h)[h][i]=babelHelpers.classPrivateFieldLooseBase(this,f)[f](e)}else{var r,o;(o=(r=babelHelpers.classPrivateFieldLooseBase(this,h)[h])[i])!=null?o:r[i]=babelHelpers.classPrivateFieldLooseBase(this,f)[f](e)}const l=await babelHelpers.classPrivateFieldLooseBase(this,h)[h][i];await s.Core.getStore().dispatch(`${a.Model.Interface}/setCounterMarks`,l)}catch(e){console.error("CalendarService: loadCounterMarks error",e)}}async loadBookingsDateCount(e,t=false){try{var r,i;const l=t?o.bookingDateCountFilter.prepareFutureOnlyFilter(e,true):o.bookingDateCountFilter.prepareUndatedFilter(e,true);const n=JSON.stringify(l);(i=(r=babelHelpers.classPrivateFieldLooseBase(this,c)[c])[n])!=null?i:r[n]=babelHelpers.classPrivateFieldLooseBase(this,g)[g](l);const d=await babelHelpers.classPrivateFieldLooseBase(this,c)[c][n];await s.Core.getStore().dispatch(`${a.Model.Filter}/setDatesCount`,d)}catch(e){console.error("CalendarService: loadBookingDatesCount error",e)}}async loadNextFilterMarks(e,t,r){const i=s.Core.getStore();try{const l=o.bookingFilter.prepareFilter(e,true);i.dispatch(`${a.Model.Filter}/setFetchingNextDate`,true);const{foundDates:n,foundDatesWithCounters:c}=await babelHelpers.classPrivateFieldLooseBase(this,F)[F](l,t,r);await Promise.all([s.Core.getStore().dispatch(`${a.Model.Filter}/addFilterDates`,n),s.Core.getStore().dispatch(`${a.Model.Filter}/setFilteredMarks`,n),s.Core.getStore().dispatch(`${a.Model.Interface}/setCounterMarks`,c)])}catch(e){console.error("BookingService: loadNextFilterMarks error",e)}finally{i.dispatch(`${a.Model.Filter}/setFetchingNextDate`,false)}}}async function H(e,t){const s=new Date;const a=new Date(s.getFullYear(),s.getMonth(),s.getDate());const o=a.getTime()+babelHelpers.classPrivateFieldLooseBase(this,B)[B];const i=Math.max(o,e)/1e3;const l=new Date(e).setMonth(new Date(e).getMonth()+1)/1e3;if(l<=o/1e3){return[]}const{freeDates:n}=await(new r.ApiClient).post("Calendar.getResourceOccupation",{timezone:babelHelpers.classPrivateFieldLooseBase(this,P)[P],dateFromTs:i,dateToTs:l,resources:t});return n}function k(e){return(new r.ApiClient).post("Calendar.getBookingsDates",{timezone:babelHelpers.classPrivateFieldLooseBase(this,P)[P],dateFromTs:e.WITHIN.DATE_FROM,dateToTs:e.WITHIN.DATE_TO,filter:e})}async function L(e,t,s){const a=i(t,s,e,babelHelpers.classPrivateFieldLooseBase(this,v)[v].bind(this));for await(const e of a){if(e.foundDates.length>0){return e}}return{foundDates:[],foundDatesWithCounters:[]}}async function y(e){const t=e/1e3;const s=new Date(e).setMonth(new Date(e).getMonth()+1)/1e3;const{foundDatesWithCounters:a}=await(new r.ApiClient).post("Calendar.getBookingsDates",{timezone:babelHelpers.classPrivateFieldLooseBase(this,P)[P],dateFromTs:t,dateToTs:s,filter:{HAS_COUNTERS_USER_ID:1}});return a}function C(e){return(new r.ApiClient).post("Calendar.getBookingsDatesCount",{timezone:babelHelpers.classPrivateFieldLooseBase(this,P)[P],filter:e})}function M(){return s.Core.getStore().getters[`${a.Model.Interface}/offset`]}function w(){return s.Core.getStore().getters[`${a.Model.Interface}/timezone`]}const T=new D;e.calendarService=T})(this.BX.Booking.Provider.Service=this.BX.Booking.Provider.Service||{},BX,BX.Booking,BX.Booking.Const,BX.Booking.Lib,BX.Booking.Lib);
//# sourceMappingURL=calendar-service.bundle.map.js