this.BX=this.BX||{};this.BX.Booking=this.BX.Booking||{};this.BX.Booking.Provider=this.BX.Booking.Provider||{};(function(t,e,i,a,s,o,r){"use strict";function d(t){return{id:t.id,createdBy:t.createdBy,createdAt:t.createdAt/1e3,updatedAt:t.updatedAt/1e3,clients:t.clients,note:t.note,externalData:t.externalData}}function c(t){const i=t.clients.filter((t=>e.Type.isArrayFilled(Object.values(t.data))));return{id:t.id,createdBy:t.createdBy,createdAt:t.createdAt*1e3,updatedAt:t.updatedAt*1e3,clients:i,note:t.note,externalData:t.externalData}}var n=babelHelpers.classPrivateFieldLooseKey("response");class l{constructor(t){Object.defineProperty(this,n,{writable:true,value:void 0});babelHelpers.classPrivateFieldLooseBase(this,n)[n]=t}getClients(){return babelHelpers.classPrivateFieldLooseBase(this,n)[n].flatMap((({clients:t})=>t)).map((t=>r.ClientMappers.mapDtoToModel(t)))}getWaitListItem(){return c(babelHelpers.classPrivateFieldLooseBase(this,n)[n])}}var p=babelHelpers.classPrivateFieldLooseKey("onAfterDelete");class L{constructor(){Object.defineProperty(this,p,{value:u})}async getById(t){try{const e=await(new s.ApiClient).post("WaitListItem.get",{id:t});const o=new l(e);await i.Core.getStore().dispatch(`${a.Model.WaitList}/upsert`,o.getWaitListItem())}catch(t){console.error("WaitListService. getById error",t)}}async add(t){const e=t.id;const r=i.Core.getStore();try{await r.dispatch(`${a.Model.WaitList}/add`,t);const i=d(t);const n=await(new s.ApiClient).post("WaitListItem.add",{waitListItem:i});const l=c(n);await r.dispatch(`${a.Model.Interface}/setAnimationPause`,true);await r.dispatch(`${a.Model.WaitList}/update`,{id:e,waitListItem:l});void o.mainPageService.fetchCounters();return{success:true,waitListItem:l}}catch(t){void r.dispatch(`${a.Model.WaitList}/delete`,e);console.error("WaitListService: add error",t);return{success:false}}finally{await r.dispatch(`${a.Model.Interface}/setAnimationPause`,false)}}async createFromBooking(t,e){const r=e.id;const d=i.Core.getStore();try{if(d.getters[`${a.Model.Interface}/isBookingCreatedFromEmbed`](t)){await d.dispatch(`${a.Model.Interface}/addCreatedFromEmbedWaitListItem`,t)}await d.dispatch(`${a.Model.WaitList}/add`,e);const i=await(new s.ApiClient).post("WaitListItem.createFromBooking",{bookingId:t});const n=c(i);await d.dispatch(`${a.Model.Interface}/setAnimationPause`,true);await Promise.all([d.dispatch(`${a.Model.WaitList}/update`,{id:r,waitListItem:n}),d.dispatch(`${a.Model.Interface}/addCreatedFromEmbedWaitListItem`,n.id)]);void o.mainPageService.fetchCounters();return{success:true,waitListItem:n}}catch(t){void d.dispatch(`${a.Model.WaitList}/delete`,r);console.error("WaitListService: createFromBooking error",t);return{success:false}}finally{await d.dispatch(`${a.Model.Interface}/setAnimationPause`,false)}}async update(t){const e=t.id;const r={...i.Core.getStore().getters[`${a.Model.WaitList}/getById`](e)};try{await i.Core.getStore().dispatch(`${a.Model.WaitList}/update`,{id:e,waitListItem:t});const r=d(t);const n=await(new s.ApiClient).post("WaitListItem.update",{waitListItem:r});const p=c(n);await i.Core.getStore().dispatch(`${a.Model.WaitList}/update`,{id:e,waitListItem:p});const L=new l([n]).getClients();await i.Core.getStore().dispatch(`${a.Model.Clients}/upsertMany`,L);void o.mainPageService.fetchCounters()}catch(t){void i.Core.getStore().dispatch(`${a.Model.WaitList}/update`,{id:e,waitListItem:r});console.error("WaitListService: update error",t)}}async delete(t){const e=i.Core.getStore();const o={...e.getters[`${a.Model.WaitList}/getById`](t)};try{await e.dispatch(`${a.Model.WaitList}/delete`,t);await(new s.ApiClient).post("WaitListItem.delete",{id:t});await babelHelpers.classPrivateFieldLooseBase(this,p)[p](t)}catch(t){await e.dispatch(`${a.Model.WaitList}/upsert`,o);console.error("WaitListItemService. delete error",t)}}async deleteList(t){const e=i.Core.getStore();const o=e.state[a.Model.WaitList].collection;const r=t.map((t=>t in o?{...o[t]}:null)).filter((t=>t!==null));try{await e.dispatch(`${a.Model.WaitList}/deleteMany`,t);await(new s.ApiClient).post("WaitListItem.deleteList",{ids:t});await Promise.all(t.map((t=>babelHelpers.classPrivateFieldLooseBase(this,p)[p](t))))}catch(t){await e.dispatch(`${a.Model.WaitList}/upsertMany`,r);console.error("WaitListService. Delete list error",t)}}}async function u(t){const e=i.Core.getStore();const s=e.getters[`${a.Model.Interface}/editingWaitListItemId`];if(t===s){await e.dispatch(`${a.Model.Interface}/setEditingWaitListItemId`,0)}await e.dispatch(`${a.Model.Interface}/addDeletingWaitListItemId`,t)}const h=new L;const m={mapModelToDto:d,mapDtoToModel:c};t.WaitListMappers=m;t.waitListService=h})(this.BX.Booking.Provider.Service=this.BX.Booking.Provider.Service||{},BX,BX.Booking,BX.Booking.Const,BX.Booking.Lib,BX.Booking.Provider.Service,BX.Booking.Provider.Service);
//# sourceMappingURL=wait-list-service.bundle.map.js